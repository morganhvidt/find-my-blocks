/**
 * Morgan's WordPress Plugin Builder File.
 *
 * Do not edit this file directly. You should instead use the wp-plugins.config.js file to setup your plugins.
 *
 * @version 1.0
 *
 * @source Documentation and more info on https://morganhvidt.com/wordpress-plugin-builder
 * @author @morganhvidt on https://x.com/morganhvidt
 *
 */
/* eslint-disable import/extensions */
/* eslint-disable no-use-before-define */
import fs from "fs";
import path from "path";
import { spawn } from "child_process";
import WP_PLUGINS from "./wp-plugins.config.js";
import webpack from "webpack";
import webpackConfig from "@wordpress/scripts/config/webpack.config.js";

const plugins = WP_PLUGINS;

async function start(mode = "build") {
  console.time("Total time");
  console.log("👋 Build Starting");

  const arg = process.argv[2];

  try {
    await Promise.all(
      plugins.map(async (plugin) => {
        const pluginConfig = plugin;
        const sourceFolder = pluginConfig.sourceFolder || "src";
        const productionFolder =
          pluginConfig.productionFolder ||
          `production/plugins/${pluginConfig.slug}`;
        const zipPath = pluginConfig.zipFolder || "production/zip";

        if (mode === "clean" || mode === "build" || mode === "production") {
          console.log(`🧼 Cleaning up: ${pluginConfig.slug}`);
          await deleteInner(productionFolder);
        }

        if (mode === "build" || mode === "production") {
          console.log(`🧱 Creating Files & Replacements: ${pluginConfig.slug}`);
          await copyFilesAndFolders(
            sourceFolder,
            productionFolder,
            pluginConfig.excludePatterns,
            replacements(pluginConfig),
            pluginConfig
          );
          console.log(`🎨 Compiling Scripts: ${pluginConfig.slug}`);
          await runWebpack(pluginConfig);
        }

        if (arg === "production") {
          console.log(`🤐 Zipping Plugin: ${pluginConfig.slug}`);
          await zipFolder(
            productionFolder,
            `${zipPath}/${pluginConfig.slug}-${pluginConfig.version}.zip`
          );
        }
      })
    );

    console.log("🎉 Build Finished");
  } catch (err) {
    console.log("🤬 Error during build:");
    console.log(err);
  } finally {
    console.timeEnd("Total time");
  }
}

let watcher;
let timeoutIds = {};

function watchPlugin(plugin) {
  const sourceFolder = plugin.sourceFolder ?? "src";
  const productionFolder =
    plugin.productionFolder || `production/plugins/${plugin.slug}`;

  watcher = fs.watch(
    sourceFolder,
    { recursive: true },
    (eventType, filename) => {
      console.log(`📁 File ${filename} changed (${eventType})`);

      // Check if the changed file matches any of the exclude patterns
      if (
        defaultExcludePatterns.some((pattern) =>
          matchPattern(filename, pattern)
        )
      ) {
        console.log(`⛔ Ignoring ${filename}`);
        return;
      }

      // Clear the previous timeout if it exists
      if (timeoutIds[plugin.slug]) {
        clearTimeout(timeoutIds[plugin.slug]);
      }

      // Set a new timeout
      timeoutIds[plugin.slug] = setTimeout(async () => {
        try {
          console.log(`🕚 Updating ${filename} in ${plugin.slug}`);
          await copyFilesAndFolders(
            sourceFolder,
            productionFolder,
            plugin.excludePatterns,
            replacements(plugin),
            plugin
          );

          // Get the extension of the file
          const ext = path.extname(filename);

          // Only run webpack for .js and .jsx files
          if (ext === ".js" || ext === ".jsx" || ext === ".css") {
            console.log(`🔄 Updating scripts in ${plugin.slug}`);
            await runWebpack(plugin, "development");
          }
          console.log(`✅ Updated ${filename} in ${plugin.slug}`);
        } catch (err) {
          console.error(
            `🤬 Error updating ${filename} in ${plugin.slug}:`,
            err
          );
        }
      }, 2500); // 5 seconds delay
    }
  );
}

function watch() {
  console.log("👀 Watching for file changes");

  plugins.forEach((plugin) => {
    watchPlugin(plugin);
  });
}

/**
 * Functions.
 */

const defaultExcludePatterns = [
  "example/readme.txt",
  "**/.git/**",
  "**.git**",
  "**/node_modules/**",
  "**/vendor/**",
  "**/dist/**",
  "**/production/**",
  "**/*.log",
  "**/*.tmp",
  "**/*.bak",
  "**/*.swp",
  "**/*.md",
  "**/composer.json",
  "**/*.DS_Store",
];

/**
 * Replace template parts through out the project.
 *
 * @param pluginConfig — array.
 * @return object.
 */
function replacements(pluginConfig) {
  const replace = [
    {
      match: "XPLUGIN_NAME",
      replacement: pluginConfig.name,
    },
    {
      match: "XPLUGIN_PREFIX_CAPITAL",
      replacement: pluginConfig.prefix_capital,
    },
    {
      match: "XPLUGIN_PREFIX",
      replacement: pluginConfig.prefix,
    },
    {
      match: "XPLUGIN_TEXT_DOMAIN",
      replacement: pluginConfig.text_domain,
    },
    {
      match: "XPLUGIN_VERSION",
      replacement: pluginConfig.version,
    },
    {
      match: "XPLUGIN_SLUG",
      replacement: pluginConfig.slug,
    },
    {
      match: "XPLUGIN_DESCRIPTION",
      replacement: pluginConfig.description,
    },
    {
      match: "XPLUGIN_EDD_ITEM_ID",
      replacement: pluginConfig.edd_item_id ? pluginConfig.edd_item_id : "",
    },
    {
      match: "XPLUGIN_EDD_STORE_URL",
      replacement: pluginConfig.edd_store_url ? pluginConfig.edd_store_url : "",
    },
    {
      match: "XPLUGIN_AUTHOR",
      replacement: pluginConfig.author ? pluginConfig.author : "",
    },
  ];

  return replace;
}

async function deleteInner(dirPath) {
  if (fs.existsSync(dirPath)) {
    const files = fs.readdirSync(dirPath);

    // eslint-disable-next-line no-restricted-syntax
    for (const file of files) {
      const filePath = path.join(dirPath, file);
      const stat = fs.lstatSync(filePath);

      if (stat.isDirectory()) {
        // Recursively delete subdirectories
        // eslint-disable-next-line no-await-in-loop
        await deleteInner(filePath);
      } else {
        // Delete files
        fs.unlinkSync(filePath);
      }
    }

    // Delete the empty directory
    fs.rmdirSync(dirPath);
  }
}

/**
 * Recursively copies files and folders from a source directory to a destination directory,
 * excluding specified path patterns and files.
 *
 * @param {string} src - The path to the source directory.
 * @param {string} dist - The path to the destination directory.
 * @param {string[]} [excludePatterns=['classes/**', 'readme.txt']] - An array of path patterns (using glob syntax) to exclude from the copying process.
 * @returns {Promise<void>} - A promise that resolves when the copying process is complete.
 */
async function copyFilesAndFolders(
  src,
  dist,
  excludePatterns = [],
  replacements = [],
  pluginConfig
) {
  excludePatterns = [...defaultExcludePatterns, ...excludePatterns];

  // Create the destination directory if it doesn't exist
  if (!fs.existsSync(dist)) {
    fs.mkdirSync(dist, { recursive: true });
  }

  // Get the list of files and folders in the source directory
  const files = fs.readdirSync(src);

  await Promise.all(
    files.map(async (file) => {
      const srcPath = path.join(src, file);
      let distPath = path.join(dist, file);

      const stat = fs.lstatSync(srcPath);

      if (excludePatterns.some((pattern) => matchPattern(srcPath, pattern))) {
        // Exclude files and folders matching the specified patterns
        return;
      }

      if (stat.isDirectory()) {
        // Recursively copy subdirectories
        await copyFilesAndFolders(
          srcPath,
          distPath,
          excludePatterns,
          replacements,
          pluginConfig
        );
      } else {
        // Rename files if needed.
        if (file.includes("XPLUGIN-SLUG")) {
          distPath = distPath.replace("XPLUGIN-SLUG", pluginConfig.slug);
        }
        // Copy files
        fs.copyFileSync(srcPath, distPath);

        // Perform text replacements in the copied file
        if (replacements.length > 0) {
          // Perform text replacements in the copied file
          let fileContent = fs.readFileSync(distPath, "utf8");

          replacements.forEach((replacement) => {
            const regex = new RegExp(replacement.match, "g");
            fileContent = fileContent.replace(regex, replacement.replacement);
          });

          // Remove blocks of code depending on the plugin type
          if (pluginConfig.type === "free") {
            const blockRegex =
              /(\/\/ @if type = 'premium'\s[\s\S]*?\/\/ @endif\s)/g;
            fileContent = fileContent.replace(blockRegex, "");

            const commentRegex =
              /(\/\/ @if type = 'free'\s)([\s\S]*?)(\/\/ @endif\s)/g;
            fileContent = fileContent.replace(commentRegex, "$2");
          } else if (pluginConfig.type === "premium") {
            const blockRegex =
              /(\/\/ @if type = 'free'\s[\s\S]*?\/\/ @endif\s)/g;
            fileContent = fileContent.replace(blockRegex, "");

            const commentRegex =
              /(\/\/ @if type = 'premium'\s)([\s\S]*?)(\/\/ @endif\s)/g;
            fileContent = fileContent.replace(commentRegex, "$2");
          }

          fs.writeFileSync(distPath, fileContent, "utf8");
        }
      }
    })
  );
}

function matchPattern(file, pattern) {
  // Convert glob pattern to regular expression
  pattern = pattern.split("/").join("\\/");
  pattern = pattern.split(".").join("\\.");
  pattern = pattern.split("*").join(".*");
  pattern = pattern.split("?").join(".");
  pattern = "^" + pattern + "$";

  const regex = new RegExp(pattern);

  return regex.test(file);
}

async function zipFolder(folderPath, outputFilePath) {
  // Convert relative paths to absolute paths.
  folderPath = path.resolve(folderPath);
  outputFilePath = path.resolve(outputFilePath);

  const outputDir = path.dirname(outputFilePath);
  const folderToZip = path.basename(folderPath);
  const parentDir = path.dirname(folderPath);

  fs.mkdirSync(outputDir, { recursive: true });

  try {
    const zipProcess = spawn("zip", ["-r", "-q", outputFilePath, folderToZip], {
      cwd: parentDir,
    });

    zipProcess.on("error", (error) => {
      console.error(`Error: ${error}`);
      throw error;
    });

    await new Promise((resolve, reject) => {
      zipProcess.on("exit", (code) => {
        if (code === 0) {
          // console.log('Zip process completed successfully');
          resolve();
        } else {
          console.error(`Zip process exited with code ${code}`);
          reject(new Error(`Zip process exited with code ${code}`));
        }
      });
    });
  } catch (error) {
    console.error(`Failed to zip folder: ${error}`);
    throw error;
  }
}
async function runWebpack(currentPlugin, mode = "production") {
  if (currentPlugin.webpack) {
    const pluginWebpackConfigs = currentPlugin.webpack.map((config) => {
      const entry = path.resolve(process.cwd(), config.entry);
      const output = path.resolve(process.cwd(), config.output.path);

      return {
        ...webpackConfig, // Default WordPress config.
        entry: entry,
        output: {
          path: output,
          filename: config.output.filename,
        },
        mode: mode,
      };
    });

    const promises = pluginWebpackConfigs.map((config) => {
      return new Promise((resolve, reject) => {
        webpack(config, (err, stats) => {
          if (err) {
            reject(err);
          } else if (stats.hasErrors()) {
            reject(new Error(stats.compilation.errors.join("\n")));
          } else {
            resolve();
          }
        });
      });
    });

    return Promise.all(promises);
  }
}

/**
 * Handle arguments.
 */
async function handleArgs() {
  const arg = process.argv[2];

  switch (arg) {
    case "clean":
      start("clean");
      break;
    case "build":
      start("build");
      break;
    case "production":
      start("production");
      break;
    case "watch":
      watch();
      break;
    case "dev":
      await start("build");
      watch();
      break;
    default:
      console.log("🤬 Error: Please provide a valid argument.");
  }
}

handleArgs();
